<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Ìè¥Î¶¨Í≥§ ÎçòÏ†Ñ ÏÑúÎ∞îÏù¥Î≤Ñ | Polygon Dungeon Survivor</title>
    <meta name="description" content="POLYGON Ïä§ÌÉÄÏùº Î°úÏö∞Ìè¥Î¶¨ ÎçòÏ†ÑÏóêÏÑú ÏÇ¥ÏïÑÎÇ®Îäî Î±ÄÏÑúÎùºÏù¥ÌÅ¨ Î°úÍ∑∏ÎùºÏù¥ÌÅ¨">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0a0f;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Segoe UI', sans-serif;
            overflow: hidden;
        }
        #gameContainer {
            position: relative;
            touch-action: none;
        }
        canvas {
            display: block;
            border: 3px solid #3a2a4a;
            border-radius: 8px;
            box-shadow: 0 0 40px rgba(120, 80, 200, 0.3);
        }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            display: flex;
            justify-content: space-between;
            color: #fff;
            font-size: 14px;
            text-shadow: 2px 2px 4px #000;
            pointer-events: none;
        }
        #levelUpModal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(20, 15, 30, 0.95);
            border: 3px solid #7850c8;
            border-radius: 16px;
            padding: 24px;
            display: none;
            flex-direction: column;
            gap: 12px;
            min-width: 280px;
            box-shadow: 0 0 60px rgba(120, 80, 200, 0.5);
        }
        #levelUpModal h2 {
            color: #ffd700;
            text-align: center;
            margin-bottom: 8px;
            text-shadow: 0 0 10px #ffd700;
        }
        .upgrade-btn {
            background: linear-gradient(135deg, #4a3a6a, #2a2040);
            border: 2px solid #7850c8;
            color: #fff;
            padding: 16px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
            text-align: left;
        }
        .upgrade-btn:hover {
            background: linear-gradient(135deg, #6a4a9a, #4a3070);
            transform: scale(1.03);
            box-shadow: 0 0 20px rgba(120, 80, 200, 0.5);
        }
        .upgrade-btn .name {
            font-weight: bold;
            color: #7dd;
            font-size: 16px;
        }
        .upgrade-btn .desc {
            color: #aaa;
            font-size: 12px;
            margin-top: 4px;
        }
        #startScreen, #gameOverScreen {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(10, 10, 20, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #fff;
            gap: 20px;
        }
        #startScreen h1 {
            font-size: 28px;
            color: #7dd;
            text-shadow: 0 0 20px #7dd;
            text-align: center;
        }
        #gameOverScreen h1 {
            color: #f55;
            text-shadow: 0 0 20px #f55;
        }
        .start-btn {
            background: linear-gradient(135deg, #50a080, #306050);
            border: none;
            color: #fff;
            padding: 16px 48px;
            border-radius: 30px;
            cursor: pointer;
            font-size: 20px;
            font-weight: bold;
            transition: all 0.2s;
        }
        .start-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(80, 160, 128, 0.6);
        }
        .stats {
            color: #aaa;
            font-size: 14px;
        }
        #hpBar {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            height: 20px;
            background: #333;
            border-radius: 10px;
            overflow: hidden;
            border: 2px solid #555;
        }
        #hpFill {
            height: 100%;
            background: linear-gradient(90deg, #f44, #f88);
            transition: width 0.2s;
        }
        #xpBar {
            position: absolute;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            width: 250px;
            height: 12px;
            background: #222;
            border-radius: 6px;
            overflow: hidden;
            border: 2px solid #444;
        }
        #xpFill {
            height: 100%;
            background: linear-gradient(90deg, #4af, #8cf);
            transition: width 0.1s;
        }
        #weaponIcons {
            position: absolute;
            top: 40px;
            left: 10px;
            display: flex;
            gap: 8px;
        }
        .weapon-icon {
            width: 40px;
            height: 40px;
            background: rgba(40, 30, 60, 0.8);
            border: 2px solid #7850c8;
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="game"></canvas>
        <div id="ui">
            <div>
                <div id="levelDisplay">Lv.1</div>
                <div id="timeDisplay">00:00</div>
            </div>
            <div>
                <div id="killDisplay">Ï≤òÏπò: 0</div>
                <div id="goldDisplay">üí∞ 0</div>
            </div>
        </div>
        <div id="weaponIcons"></div>
        <div id="xpBar"><div id="xpFill"></div></div>
        <div id="hpBar"><div id="hpFill"></div></div>
        <div id="levelUpModal">
            <h2>‚öîÔ∏è Î†àÎ≤® ÏóÖ!</h2>
            <div id="upgradeOptions"></div>
        </div>
        <div id="startScreen">
            <h1>üè∞ Ìè¥Î¶¨Í≥§ ÎçòÏ†Ñ ÏÑúÎ∞îÏù¥Î≤Ñ</h1>
            <p style="color:#888">Î¨¥ÌïúÌûà Î∞ÄÎ†§Ïò§Îäî Ï†ÅÎì§ÏùÑ Ï≤òÏπòÌïòÍ≥† ÏÉùÏ°¥ÌïòÎùº!</p>
            <button class="start-btn" onclick="startGame()">Í≤åÏûÑ ÏãúÏûë</button>
            <p style="color:#666;font-size:12px">Ïù¥Îèô: WASD / Î∞©Ìñ•ÌÇ§ / ÌÑ∞Ïπò</p>
        </div>
        <div id="gameOverScreen" style="display:none">
            <h1>üíÄ Í≤åÏûÑ Ïò§Î≤Ñ</h1>
            <div class="stats">
                <p id="finalTime">ÏÉùÏ°¥ ÏãúÍ∞Ñ: 00:00</p>
                <p id="finalKills">Ï≤òÏπò Ïàò: 0</p>
                <p id="finalLevel">ÎèÑÎã¨ Î†àÎ≤®: 1</p>
            </div>
            <button class="start-btn" onclick="startGame()">Îã§Ïãú ÏãúÏûë</button>
        </div>
    </div>
    <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    
    // Responsive canvas
    function resize() {
        const size = Math.min(window.innerWidth - 20, window.innerHeight - 20, 600);
        canvas.width = size;
        canvas.height = size;
    }
    resize();
    window.addEventListener('resize', resize);
    
    // Game state
    let game = null;
    let animationId = null;
    
    // Colors - Low Poly Style
    const COLORS = {
        floor: '#1a1520',
        floorTile: '#252030',
        player: '#4af',
        playerOutline: '#2af',
        enemy: {
            skeleton: '#e8e0d0',
            zombie: '#5a8050',
            ghost: '#8080f0',
            boss: '#f04040'
        },
        gem: '#4ff',
        gold: '#ffd700',
        damage: '#f44',
        heal: '#4f4'
    };
    
    // Weapon types
    const WEAPONS = {
        sword: { name: 'Í≤Ä', icon: '‚öîÔ∏è', damage: 25, cooldown: 800, range: 60, type: 'melee' },
        bow: { name: 'Ìôú', icon: 'üèπ', damage: 15, cooldown: 500, range: 200, type: 'ranged', speed: 8 },
        magic: { name: 'ÎßàÎ≤ï', icon: '‚ú®', damage: 20, cooldown: 1200, range: 120, type: 'aoe', radius: 80 },
        orb: { name: 'Ïò§Î∏å', icon: 'üîÆ', damage: 10, cooldown: 300, range: 150, type: 'orbit' },
        lightning: { name: 'Î≤àÍ∞ú', icon: '‚ö°', damage: 35, cooldown: 1500, range: 180, type: 'chain' }
    };
    
    // Upgrades
    const UPGRADES = [
        { id: 'sword', name: 'Í≤Ä Í∞ïÌôî', desc: 'Í∑ºÏ†ë Í≤Ä ÌöçÎìù/Í∞ïÌôî', weapon: 'sword' },
        { id: 'bow', name: 'Ìôú Í∞ïÌôî', desc: 'ÏõêÍ±∞Î¶¨ ÌôîÏÇ¥ ÌöçÎìù/Í∞ïÌôî', weapon: 'bow' },
        { id: 'magic', name: 'ÎßàÎ≤ï Í∞ïÌôî', desc: 'Î≤îÏúÑ ÎßàÎ≤ï ÌöçÎìù/Í∞ïÌôî', weapon: 'magic' },
        { id: 'orb', name: 'Ïò§Î∏å Í∞ïÌôî', desc: 'ÌöåÏ†Ñ Ïò§Î∏å ÌöçÎìù/Í∞ïÌôî', weapon: 'orb' },
        { id: 'lightning', name: 'Î≤àÍ∞ú Í∞ïÌôî', desc: 'Ïó∞ÏáÑ Î≤àÍ∞ú ÌöçÎìù/Í∞ïÌôî', weapon: 'lightning' },
        { id: 'speed', name: 'Ïù¥Îèô ÏÜçÎèÑ', desc: 'Ïù¥Îèô ÏÜçÎèÑ +15%', stat: 'speed', value: 0.15 },
        { id: 'maxHp', name: 'Ï≤¥Î†• Ï¶ùÍ∞Ä', desc: 'ÏµúÎåÄ Ï≤¥Î†• +20', stat: 'maxHp', value: 20 },
        { id: 'regen', name: 'Ïû¨ÏÉùÎ†•', desc: 'Ï¥àÎãπ HP ÌöåÎ≥µ +0.5', stat: 'regen', value: 0.5 },
        { id: 'magnet', name: 'ÏûêÏÑù', desc: 'ÏïÑÏù¥ÌÖú ÏàòÏßë Î≤îÏúÑ +20', stat: 'magnet', value: 20 },
        { id: 'luck', name: 'ÌñâÏö¥', desc: 'ÏïÑÏù¥ÌÖú ÎìúÎûçÎ•† +10%', stat: 'luck', value: 0.1 }
    ];
    
    class Game {
        constructor() {
            this.player = {
                x: canvas.width / 2,
                y: canvas.height / 2,
                radius: 16,
                hp: 100,
                maxHp: 100,
                speed: 3,
                xp: 0,
                xpToLevel: 10,
                level: 1,
                regen: 0,
                magnet: 50,
                luck: 0,
                weapons: {},
                invincible: 0
            };
            this.enemies = [];
            this.projectiles = [];
            this.gems = [];
            this.particles = [];
            this.effects = [];
            this.orbs = [];
            
            this.kills = 0;
            this.gold = 0;
            this.gameTime = 0;
            this.lastTime = Date.now();
            this.spawnTimer = 0;
            this.spawnRate = 2000;
            this.difficulty = 1;
            this.paused = false;
            this.gameOver = false;
            
            this.camera = { x: 0, y: 0 };
            this.input = { x: 0, y: 0 };
            
            this.setupInput();
            this.addWeapon('sword');
        }
        
        setupInput() {
            this.keys = {};
            window.addEventListener('keydown', e => this.keys[e.key.toLowerCase()] = true);
            window.addEventListener('keyup', e => this.keys[e.key.toLowerCase()] = false);
            
            // Touch/mouse joystick
            this.touchStart = null;
            canvas.addEventListener('touchstart', e => {
                e.preventDefault();
                this.touchStart = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            });
            canvas.addEventListener('touchmove', e => {
                e.preventDefault();
                if (this.touchStart) {
                    const dx = e.touches[0].clientX - this.touchStart.x;
                    const dy = e.touches[0].clientY - this.touchStart.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist > 10) {
                        this.input.x = dx / dist;
                        this.input.y = dy / dist;
                    }
                }
            });
            canvas.addEventListener('touchend', () => {
                this.touchStart = null;
                this.input = { x: 0, y: 0 };
            });
        }
        
        addWeapon(type) {
            if (!this.player.weapons[type]) {
                this.player.weapons[type] = { level: 1, cooldown: 0 };
            } else {
                this.player.weapons[type].level++;
            }
            this.updateWeaponUI();
        }
        
        updateWeaponUI() {
            const container = document.getElementById('weaponIcons');
            container.innerHTML = '';
            for (const [type, data] of Object.entries(this.player.weapons)) {
                const div = document.createElement('div');
                div.className = 'weapon-icon';
                div.innerHTML = WEAPONS[type].icon;
                div.title = `${WEAPONS[type].name} Lv.${data.level}`;
                container.appendChild(div);
            }
        }
        
        spawnEnemy() {
            const angle = Math.random() * Math.PI * 2;
            const dist = canvas.width / 2 + 50;
            const x = this.player.x + Math.cos(angle) * dist;
            const y = this.player.y + Math.sin(angle) * dist;
            
            const types = ['skeleton', 'zombie', 'ghost'];
            const type = types[Math.floor(Math.random() * types.length)];
            
            const baseHp = { skeleton: 30, zombie: 50, ghost: 25 };
            const baseSpeed = { skeleton: 1.5, zombie: 1, ghost: 2 };
            const baseDamage = { skeleton: 10, zombie: 15, ghost: 8 };
            
            this.enemies.push({
                x, y,
                type,
                hp: baseHp[type] * this.difficulty,
                maxHp: baseHp[type] * this.difficulty,
                speed: baseSpeed[type],
                damage: baseDamage[type] * Math.sqrt(this.difficulty),
                radius: type === 'ghost' ? 12 : 14,
                hitFlash: 0
            });
        }
        
        spawnBoss() {
            const angle = Math.random() * Math.PI * 2;
            const dist = canvas.width / 2 + 100;
            this.enemies.push({
                x: this.player.x + Math.cos(angle) * dist,
                y: this.player.y + Math.sin(angle) * dist,
                type: 'boss',
                hp: 500 * this.difficulty,
                maxHp: 500 * this.difficulty,
                speed: 0.8,
                damage: 30,
                radius: 30,
                hitFlash: 0,
                isBoss: true
            });
        }
        
        update(dt) {
            if (this.paused || this.gameOver) return;
            
            this.gameTime += dt;
            this.difficulty = 1 + this.gameTime / 60; // Increase every minute
            
            // Player regen
            if (this.player.regen > 0) {
                this.player.hp = Math.min(this.player.maxHp, this.player.hp + this.player.regen * dt);
            }
            
            // Invincibility
            if (this.player.invincible > 0) this.player.invincible -= dt;
            
            // Input
            let dx = this.input.x, dy = this.input.y;
            if (this.keys['w'] || this.keys['arrowup']) dy -= 1;
            if (this.keys['s'] || this.keys['arrowdown']) dy += 1;
            if (this.keys['a'] || this.keys['arrowleft']) dx -= 1;
            if (this.keys['d'] || this.keys['arrowright']) dx += 1;
            
            const len = Math.sqrt(dx*dx + dy*dy);
            if (len > 0) {
                this.player.x += (dx / len) * this.player.speed;
                this.player.y += (dy / len) * this.player.speed;
            }
            
            // Spawn enemies
            this.spawnTimer += dt * 1000;
            if (this.spawnTimer >= this.spawnRate / this.difficulty) {
                this.spawnTimer = 0;
                const count = Math.floor(1 + this.difficulty / 2);
                for (let i = 0; i < count; i++) this.spawnEnemy();
            }
            
            // Boss every 60 seconds
            if (Math.floor(this.gameTime) % 60 === 0 && Math.floor(this.gameTime) > 0 && 
                !this.enemies.some(e => e.isBoss)) {
                this.spawnBoss();
            }
            
            // Update weapons
            this.updateWeapons(dt);
            
            // Update enemies
            for (const enemy of this.enemies) {
                const dx = this.player.x - enemy.x;
                const dy = this.player.y - enemy.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                if (dist > 0) {
                    enemy.x += (dx / dist) * enemy.speed;
                    enemy.y += (dy / dist) * enemy.speed;
                }
                
                // Hit player
                if (dist < this.player.radius + enemy.radius && this.player.invincible <= 0) {
                    this.player.hp -= enemy.damage;
                    this.player.invincible = 0.5;
                    this.screenShake(10);
                    this.addParticle(this.player.x, this.player.y, COLORS.damage, 10);
                    
                    if (this.player.hp <= 0) {
                        this.endGame();
                    }
                }
                
                if (enemy.hitFlash > 0) enemy.hitFlash -= dt;
            }
            
            // Update projectiles
            for (let i = this.projectiles.length - 1; i >= 0; i--) {
                const p = this.projectiles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life -= dt;
                
                // Hit enemies
                for (const enemy of this.enemies) {
                    const dx = p.x - enemy.x;
                    const dy = p.y - enemy.y;
                    if (Math.sqrt(dx*dx + dy*dy) < enemy.radius + p.radius) {
                        this.damageEnemy(enemy, p.damage);
                        if (!p.pierce) p.life = 0;
                        break;
                    }
                }
                
                if (p.life <= 0) this.projectiles.splice(i, 1);
            }
            
            // Update gems
            for (let i = this.gems.length - 1; i >= 0; i--) {
                const gem = this.gems[i];
                const dx = this.player.x - gem.x;
                const dy = this.player.y - gem.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                if (dist < this.player.magnet) {
                    gem.x += (dx / dist) * 5;
                    gem.y += (dy / dist) * 5;
                }
                
                if (dist < this.player.radius + 10) {
                    if (gem.type === 'xp') {
                        this.player.xp += gem.value;
                        if (this.player.xp >= this.player.xpToLevel) {
                            this.levelUp();
                        }
                    } else if (gem.type === 'gold') {
                        this.gold += gem.value;
                    } else if (gem.type === 'heal') {
                        this.player.hp = Math.min(this.player.maxHp, this.player.hp + 20);
                        this.addParticle(this.player.x, this.player.y, COLORS.heal, 8);
                    }
                    this.gems.splice(i, 1);
                }
            }
            
            // Update particles
            for (let i = this.particles.length - 1; i >= 0; i--) {
                const p = this.particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life -= dt;
                p.vy += 0.1;
                if (p.life <= 0) this.particles.splice(i, 1);
            }
            
            // Update orbs
            for (const orb of this.orbs) {
                orb.angle += orb.speed;
                orb.x = this.player.x + Math.cos(orb.angle) * orb.dist;
                orb.y = this.player.y + Math.sin(orb.angle) * orb.dist;
                
                // Hit enemies
                for (const enemy of this.enemies) {
                    const dx = orb.x - enemy.x;
                    const dy = orb.y - enemy.y;
                    if (Math.sqrt(dx*dx + dy*dy) < enemy.radius + orb.radius) {
                        if (!orb.hitList.has(enemy)) {
                            this.damageEnemy(enemy, orb.damage);
                            orb.hitList.add(enemy);
                            setTimeout(() => orb.hitList.delete(enemy), 500);
                        }
                    }
                }
            }
            
            // Camera follow
            this.camera.x = this.player.x - canvas.width / 2;
            this.camera.y = this.player.y - canvas.height / 2;
            
            // Remove dead enemies
            this.enemies = this.enemies.filter(e => e.hp > 0);
            
            // Update UI
            this.updateUI();
        }
        
        updateWeapons(dt) {
            for (const [type, data] of Object.entries(this.player.weapons)) {
                data.cooldown -= dt * 1000;
                if (data.cooldown <= 0) {
                    const weapon = WEAPONS[type];
                    const cooldown = weapon.cooldown / (1 + data.level * 0.1);
                    data.cooldown = cooldown;
                    
                    const target = this.findNearestEnemy(weapon.range * (1 + data.level * 0.1));
                    if (!target && type !== 'orb') continue;
                    
                    const damage = weapon.damage * (1 + data.level * 0.2);
                    
                    if (type === 'sword') {
                        // Melee slash
                        this.effects.push({
                            type: 'slash',
                            x: this.player.x,
                            y: this.player.y,
                            angle: target ? Math.atan2(target.y - this.player.y, target.x - this.player.x) : 0,
                            radius: weapon.range * (1 + data.level * 0.1),
                            life: 0.2
                        });
                        for (const enemy of this.enemies) {
                            const dx = enemy.x - this.player.x;
                            const dy = enemy.y - this.player.y;
                            if (Math.sqrt(dx*dx + dy*dy) < weapon.range * (1 + data.level * 0.1)) {
                                this.damageEnemy(enemy, damage);
                            }
                        }
                    } else if (type === 'bow') {
                        const count = Math.min(data.level, 5);
                        for (let i = 0; i < count; i++) {
                            const spread = (i - (count-1)/2) * 0.2;
                            const angle = Math.atan2(target.y - this.player.y, target.x - this.player.x) + spread;
                            this.projectiles.push({
                                x: this.player.x,
                                y: this.player.y,
                                vx: Math.cos(angle) * weapon.speed,
                                vy: Math.sin(angle) * weapon.speed,
                                damage,
                                radius: 5,
                                life: 2,
                                color: '#fa0'
                            });
                        }
                    } else if (type === 'magic') {
                        this.effects.push({
                            type: 'explosion',
                            x: target.x,
                            y: target.y,
                            radius: weapon.radius * (1 + data.level * 0.1),
                            life: 0.3,
                            maxLife: 0.3
                        });
                        for (const enemy of this.enemies) {
                            const dx = enemy.x - target.x;
                            const dy = enemy.y - target.y;
                            if (Math.sqrt(dx*dx + dy*dy) < weapon.radius * (1 + data.level * 0.1)) {
                                this.damageEnemy(enemy, damage);
                            }
                        }
                    } else if (type === 'orb') {
                        if (this.orbs.length < data.level + 2) {
                            this.orbs.push({
                                angle: (this.orbs.length / (data.level + 2)) * Math.PI * 2,
                                dist: 60,
                                speed: 0.05,
                                damage: damage,
                                radius: 12,
                                x: this.player.x,
                                y: this.player.y,
                                hitList: new Set()
                            });
                        }
                    } else if (type === 'lightning') {
                        if (target) {
                            const chainCount = 2 + data.level;
                            let current = target;
                            const hit = new Set([current]);
                            
                            for (let i = 0; i < chainCount && current; i++) {
                                this.damageEnemy(current, damage * Math.pow(0.8, i));
                                this.effects.push({
                                    type: 'lightning',
                                    x1: i === 0 ? this.player.x : this.effects[this.effects.length-1]?.x2 || this.player.x,
                                    y1: i === 0 ? this.player.y : this.effects[this.effects.length-1]?.y2 || this.player.y,
                                    x2: current.x,
                                    y2: current.y,
                                    life: 0.2
                                });
                                
                                // Find next target
                                let next = null;
                                let minDist = 150;
                                for (const e of this.enemies) {
                                    if (hit.has(e)) continue;
                                    const d = Math.sqrt((e.x-current.x)**2 + (e.y-current.y)**2);
                                    if (d < minDist) {
                                        minDist = d;
                                        next = e;
                                    }
                                }
                                if (next) hit.add(next);
                                current = next;
                            }
                        }
                    }
                }
            }
        }
        
        findNearestEnemy(range) {
            let nearest = null;
            let minDist = range;
            for (const enemy of this.enemies) {
                const dx = enemy.x - this.player.x;
                const dy = enemy.y - this.player.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist < minDist) {
                    minDist = dist;
                    nearest = enemy;
                }
            }
            return nearest;
        }
        
        damageEnemy(enemy, damage) {
            enemy.hp -= damage;
            enemy.hitFlash = 0.1;
            this.addParticle(enemy.x, enemy.y, '#fff', 5);
            this.screenShake(3);
            
            if (enemy.hp <= 0) {
                this.kills++;
                
                // Drop gems
                const xpCount = enemy.isBoss ? 10 : 1 + Math.floor(Math.random() * 2);
                for (let i = 0; i < xpCount; i++) {
                    this.gems.push({
                        x: enemy.x + (Math.random() - 0.5) * 20,
                        y: enemy.y + (Math.random() - 0.5) * 20,
                        type: 'xp',
                        value: enemy.isBoss ? 5 : 1
                    });
                }
                
                // Gold chance
                if (Math.random() < 0.3 + this.player.luck) {
                    this.gems.push({
                        x: enemy.x,
                        y: enemy.y,
                        type: 'gold',
                        value: enemy.isBoss ? 50 : 5
                    });
                }
                
                // Heal chance
                if (Math.random() < 0.05 + this.player.luck * 0.5) {
                    this.gems.push({
                        x: enemy.x,
                        y: enemy.y,
                        type: 'heal',
                        value: 20
                    });
                }
                
                // Death particles
                for (let i = 0; i < 8; i++) {
                    this.addParticle(enemy.x, enemy.y, COLORS.enemy[enemy.type], 6);
                }
            }
        }
        
        addParticle(x, y, color, count) {
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 2 + Math.random() * 3;
                this.particles.push({
                    x, y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    color,
                    radius: 3 + Math.random() * 3,
                    life: 0.3 + Math.random() * 0.3
                });
            }
        }
        
        screenShake(intensity) {
            this.shakeIntensity = intensity;
            setTimeout(() => this.shakeIntensity = 0, 100);
        }
        
        levelUp() {
            this.player.level++;
            this.player.xp -= this.player.xpToLevel;
            this.player.xpToLevel = Math.floor(this.player.xpToLevel * 1.5);
            this.paused = true;
            this.showLevelUpModal();
        }
        
        showLevelUpModal() {
            const modal = document.getElementById('levelUpModal');
            const options = document.getElementById('upgradeOptions');
            options.innerHTML = '';
            
            // Pick 3 random upgrades
            const available = [...UPGRADES].sort(() => Math.random() - 0.5).slice(0, 3);
            
            for (const upgrade of available) {
                const btn = document.createElement('button');
                btn.className = 'upgrade-btn';
                
                let levelText = '';
                if (upgrade.weapon) {
                    const current = this.player.weapons[upgrade.weapon]?.level || 0;
                    levelText = current > 0 ? ` (Lv.${current} ‚Üí ${current+1})` : ' (Ïã†Í∑ú!)';
                }
                
                btn.innerHTML = `<div class="name">${upgrade.name}${levelText}</div><div class="desc">${upgrade.desc}</div>`;
                btn.onclick = () => this.selectUpgrade(upgrade);
                options.appendChild(btn);
            }
            
            modal.style.display = 'flex';
        }
        
        selectUpgrade(upgrade) {
            if (upgrade.weapon) {
                this.addWeapon(upgrade.weapon);
            } else if (upgrade.stat) {
                this.player[upgrade.stat] += upgrade.value;
                if (upgrade.stat === 'maxHp') {
                    this.player.hp += upgrade.value;
                }
            }
            
            document.getElementById('levelUpModal').style.display = 'none';
            this.paused = false;
        }
        
        updateUI() {
            const time = Math.floor(this.gameTime);
            const mins = Math.floor(time / 60).toString().padStart(2, '0');
            const secs = (time % 60).toString().padStart(2, '0');
            
            document.getElementById('levelDisplay').textContent = `Lv.${this.player.level}`;
            document.getElementById('timeDisplay').textContent = `${mins}:${secs}`;
            document.getElementById('killDisplay').textContent = `Ï≤òÏπò: ${this.kills}`;
            document.getElementById('goldDisplay').textContent = `üí∞ ${this.gold}`;
            
            document.getElementById('hpFill').style.width = `${(this.player.hp / this.player.maxHp) * 100}%`;
            document.getElementById('xpFill').style.width = `${(this.player.xp / this.player.xpToLevel) * 100}%`;
        }
        
        draw() {
            ctx.save();
            
            // Camera shake
            if (this.shakeIntensity) {
                ctx.translate(
                    (Math.random() - 0.5) * this.shakeIntensity,
                    (Math.random() - 0.5) * this.shakeIntensity
                );
            }
            
            // Background
            ctx.fillStyle = COLORS.floor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Floor tiles (dungeon feel)
            ctx.fillStyle = COLORS.floorTile;
            const tileSize = 40;
            const offsetX = -this.camera.x % tileSize;
            const offsetY = -this.camera.y % tileSize;
            for (let x = -tileSize; x < canvas.width + tileSize; x += tileSize) {
                for (let y = -tileSize; y < canvas.height + tileSize; y += tileSize) {
                    if ((Math.floor((x + this.camera.x) / tileSize) + Math.floor((y + this.camera.y) / tileSize)) % 2 === 0) {
                        ctx.fillRect(x + offsetX, y + offsetY, tileSize - 2, tileSize - 2);
                    }
                }
            }
            
            ctx.translate(-this.camera.x, -this.camera.y);
            
            // Draw gems
            for (const gem of this.gems) {
                ctx.beginPath();
                if (gem.type === 'xp') {
                    ctx.fillStyle = COLORS.gem;
                    this.drawPolygon(gem.x, gem.y, 6, 6);
                } else if (gem.type === 'gold') {
                    ctx.fillStyle = COLORS.gold;
                    this.drawPolygon(gem.x, gem.y, 8, 5);
                } else if (gem.type === 'heal') {
                    ctx.fillStyle = COLORS.heal;
                    ctx.fillRect(gem.x - 4, gem.y - 2, 8, 4);
                    ctx.fillRect(gem.x - 2, gem.y - 4, 4, 8);
                }
            }
            
            // Draw enemies
            for (const enemy of this.enemies) {
                ctx.save();
                ctx.translate(enemy.x, enemy.y);
                
                const color = enemy.hitFlash > 0 ? '#fff' : COLORS.enemy[enemy.type];
                ctx.fillStyle = color;
                
                if (enemy.type === 'skeleton') {
                    // Low poly skeleton
                    this.drawPolygon(0, 0, enemy.radius, 6);
                    ctx.fillStyle = '#222';
                    ctx.beginPath();
                    ctx.arc(-4, -3, 3, 0, Math.PI * 2);
                    ctx.arc(4, -3, 3, 0, Math.PI * 2);
                    ctx.fill();
                } else if (enemy.type === 'zombie') {
                    // Low poly zombie
                    this.drawPolygon(0, 0, enemy.radius, 5);
                    ctx.fillStyle = '#2a4020';
                    ctx.fillRect(-5, 2, 10, 4);
                } else if (enemy.type === 'ghost') {
                    // Ghostly shape
                    ctx.globalAlpha = 0.7;
                    this.drawPolygon(0, 0, enemy.radius, 8);
                    ctx.globalAlpha = 1;
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(-3, -2, 2, 0, Math.PI * 2);
                    ctx.arc(3, -2, 2, 0, Math.PI * 2);
                    ctx.fill();
                } else if (enemy.type === 'boss') {
                    // Big boss
                    ctx.fillStyle = enemy.hitFlash > 0 ? '#fff' : COLORS.enemy.boss;
                    this.drawPolygon(0, 0, enemy.radius, 8);
                    ctx.fillStyle = '#800';
                    ctx.font = 'bold 20px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText('üëπ', 0, 6);
                    
                    // HP bar
                    ctx.fillStyle = '#400';
                    ctx.fillRect(-25, -enemy.radius - 10, 50, 6);
                    ctx.fillStyle = '#f44';
                    ctx.fillRect(-25, -enemy.radius - 10, 50 * (enemy.hp / enemy.maxHp), 6);
                }
                
                ctx.restore();
            }
            
            // Draw orbs
            for (const orb of this.orbs) {
                ctx.fillStyle = '#a6f';
                ctx.shadowColor = '#a6f';
                ctx.shadowBlur = 15;
                ctx.beginPath();
                ctx.arc(orb.x, orb.y, orb.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            }
            
            // Draw projectiles
            for (const p of this.projectiles) {
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Draw effects
            for (let i = this.effects.length - 1; i >= 0; i--) {
                const e = this.effects[i];
                e.life -= 0.016;
                
                if (e.type === 'slash') {
                    ctx.save();
                    ctx.translate(this.player.x, this.player.y);
                    ctx.rotate(e.angle);
                    ctx.fillStyle = `rgba(200, 220, 255, ${e.life * 3})`;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.arc(0, 0, e.radius, -0.5, 0.5);
                    ctx.fill();
                    ctx.restore();
                } else if (e.type === 'explosion') {
                    const progress = 1 - e.life / e.maxLife;
                    ctx.fillStyle = `rgba(150, 100, 255, ${e.life * 2})`;
                    ctx.beginPath();
                    ctx.arc(e.x, e.y, e.radius * progress, 0, Math.PI * 2);
                    ctx.fill();
                } else if (e.type === 'lightning') {
                    ctx.strokeStyle = `rgba(180, 200, 255, ${e.life * 5})`;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(e.x1, e.y1);
                    // Jagged line
                    const dx = e.x2 - e.x1, dy = e.y2 - e.y1;
                    const segments = 4;
                    for (let j = 1; j <= segments; j++) {
                        const t = j / segments;
                        const jitter = j < segments ? (Math.random() - 0.5) * 20 : 0;
                        ctx.lineTo(e.x1 + dx * t + jitter, e.y1 + dy * t + jitter);
                    }
                    ctx.stroke();
                }
                
                if (e.life <= 0) this.effects.splice(i, 1);
            }
            
            // Draw particles
            for (const p of this.particles) {
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life * 2;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
            
            // Draw player
            ctx.save();
            ctx.translate(this.player.x, this.player.y);
            
            if (this.player.invincible > 0) {
                ctx.globalAlpha = 0.5 + Math.sin(Date.now() * 0.02) * 0.3;
            }
            
            // Low poly player
            ctx.fillStyle = COLORS.player;
            this.drawPolygon(0, 0, this.player.radius, 6);
            
            ctx.strokeStyle = COLORS.playerOutline;
            ctx.lineWidth = 2;
            ctx.beginPath();
            this.drawPolygonPath(0, 0, this.player.radius, 6);
            ctx.stroke();
            
            // Face
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(-4, -3, 3, 0, Math.PI * 2);
            ctx.arc(4, -3, 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(-4, -3, 1.5, 0, Math.PI * 2);
            ctx.arc(4, -3, 1.5, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
            ctx.restore();
        }
        
        drawPolygon(x, y, radius, sides) {
            ctx.beginPath();
            this.drawPolygonPath(x, y, radius, sides);
            ctx.fill();
        }
        
        drawPolygonPath(x, y, radius, sides) {
            for (let i = 0; i < sides; i++) {
                const angle = (i / sides) * Math.PI * 2 - Math.PI / 2;
                const px = x + Math.cos(angle) * radius;
                const py = y + Math.sin(angle) * radius;
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.closePath();
        }
        
        endGame() {
            this.gameOver = true;
            document.getElementById('gameOverScreen').style.display = 'flex';
            
            const time = Math.floor(this.gameTime);
            const mins = Math.floor(time / 60).toString().padStart(2, '0');
            const secs = (time % 60).toString().padStart(2, '0');
            
            document.getElementById('finalTime').textContent = `ÏÉùÏ°¥ ÏãúÍ∞Ñ: ${mins}:${secs}`;
            document.getElementById('finalKills').textContent = `Ï≤òÏπò Ïàò: ${this.kills}`;
            document.getElementById('finalLevel').textContent = `ÎèÑÎã¨ Î†àÎ≤®: ${this.player.level}`;
        }
    }
    
    function gameLoop() {
        if (game) {
            const now = Date.now();
            const dt = (now - game.lastTime) / 1000;
            game.lastTime = now;
            
            game.update(Math.min(dt, 0.1));
            game.draw();
        }
        animationId = requestAnimationFrame(gameLoop);
    }
    
    function startGame() {
        document.getElementById('startScreen').style.display = 'none';
        document.getElementById('gameOverScreen').style.display = 'none';
        document.getElementById('levelUpModal').style.display = 'none';
        
        if (animationId) cancelAnimationFrame(animationId);
        
        game = new Game();
        game.lastTime = Date.now();
        gameLoop();
    }
    </script>
</body>
</html>
