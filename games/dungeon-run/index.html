<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ğŸƒ í¬ì¼“ ë˜ì „ ëŸ°</title>
    <!--
        ============================================
        í¬ì¼“ ë˜ì „ ëŸ° (Pocket Dungeon Run)
        ============================================
        
        ì—ì…‹ ì¶œì²˜ ë° ë¼ì´ì„ ìŠ¤:
        - ëª¨ë“  ìŠ¤í”„ë¼ì´íŠ¸ëŠ” Canvas APIë¡œ ì§ì ‘ ìƒì„±ëœ í”½ì…€ ì•„íŠ¸ì…ë‹ˆë‹¤
        - ì˜ê°: Kenney.nlì˜ Tiny Dungeon & Pixel Platformer (CC0 ë¼ì´ì„ ìŠ¤)
        - ì›ë³¸ ì½”ë“œ ë° ì•„íŠ¸: MIT ë¼ì´ì„ ìŠ¤ë¡œ ììœ ë¡­ê²Œ ì‚¬ìš© ê°€ëŠ¥
        
        Asset Credits & License:
        - All sprites are procedurally generated pixel art using Canvas API
        - Inspired by: Kenney.nl's Tiny Dungeon & Pixel Platformer (CC0)
        - Original code and art: Free to use under MIT license
        ============================================
    -->
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            background: #0a0a12;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Segoe UI', sans-serif;
            overflow: hidden;
            touch-action: none;
        }
        #gameContainer {
            position: relative;
            width: 100%;
            max-width: 800px;
        }
        canvas {
            display: block;
            width: 100%;
            height: auto;
            border-radius: 8px;
            box-shadow: 0 0 40px rgba(139, 69, 19, 0.4);
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            display: flex;
            justify-content: space-between;
            color: #ffd700;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.9), 0 0 10px rgba(255,215,0,0.3);
            pointer-events: none;
            font-family: monospace;
        }
        #startScreen, #gameOverScreen {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0,0,0,0.9);
            color: #fff;
            border-radius: 8px;
        }
        #startScreen h1, #gameOverScreen h1 {
            font-size: 2.5em;
            margin-bottom: 20px;
            text-shadow: 0 0 20px #8b4513, 0 0 40px #cd853f;
            color: #ffd700;
        }
        #startScreen p, #gameOverScreen p {
            font-size: 1.2em;
            margin-bottom: 10px;
            opacity: 0.8;
        }
        .btn {
            margin-top: 20px;
            padding: 15px 40px;
            font-size: 1.3em;
            background: linear-gradient(135deg, #8b4513, #cd853f);
            border: 3px solid #ffd700;
            border-radius: 8px;
            color: #fff;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 5px 20px rgba(139, 69, 19, 0.6);
            font-family: monospace;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        .btn:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 30px rgba(205, 133, 63, 0.8);
        }
        #finalScore {
            font-size: 2em;
            color: #ffd700;
            margin: 10px 0;
        }
        .hidden { display: none !important; }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="game"></canvas>
        <div id="ui">
            <span id="score">âš”ï¸ 0m</span>
            <span id="coins">ğŸ’ 0</span>
        </div>
        
        <div id="startScreen">
            <h1>âš”ï¸ í¬ì¼“ ë˜ì „ ëŸ°</h1>
            <p>ğŸ® í„°ì¹˜ ë˜ëŠ” ìŠ¤í˜ì´ìŠ¤ë°”ë¡œ ì í”„!</p>
            <p>ğŸ’€ í•¨ì •ì„ í”¼í•˜ê³  ë³´ì„ì„ ëª¨ì•„ë¼!</p>
            <button class="btn" id="startBtn">ëª¨í—˜ ì‹œì‘</button>
        </div>
        
        <div id="gameOverScreen" class="hidden">
            <h1>ğŸ’€ ì‚¬ë§</h1>
            <p>ë„ë‹¬ ê±°ë¦¬</p>
            <div id="finalScore">0m</div>
            <p id="finalCoins">ğŸ’ 0ê°œ ìˆ˜ì§‘</p>
            <button class="btn" id="restartBtn">ì¬ë„ì „</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        
        // ìº”ë²„ìŠ¤ í¬ê¸° ì„¤ì •
        const BASE_WIDTH = 800;
        const BASE_HEIGHT = 400;
        canvas.width = BASE_WIDTH;
        canvas.height = BASE_HEIGHT;
        
        // í”½ì…€ ìŠ¤ì¼€ì¼ (ë” í° í”½ì…€ ë£©)
        const PIXEL_SCALE = 2;
        
        // ============================================
        // ìƒ‰ìƒ íŒ”ë ˆíŠ¸ (ë˜ì „ í…Œë§ˆ)
        // ============================================
        const PALETTE = {
            // ìºë¦­í„°
            skin: '#f4c896',
            skinDark: '#d4a876',
            hair: '#4a3728',
            armor: '#5a7a9a',
            armorLight: '#7a9aba',
            armorDark: '#3a5a7a',
            cape: '#c44', 
            capeDark: '#922',
            
            // ë˜ì „
            stone: '#4a4a5a',
            stoneDark: '#2a2a3a',
            stoneLight: '#6a6a7a',
            brick: '#5a4a3a',
            brickDark: '#3a2a1a',
            moss: '#3a5a3a',
            
            // ì¥ì• ë¬¼
            spike: '#8a8a9a',
            spikeLight: '#aaaabc',
            monster: '#6a3a6a',
            monsterLight: '#8a5a8a',
            monsterEye: '#ff0',
            bat: '#3a3a4a',
            batWing: '#5a5a6a',
            fire: '#f84',
            fireLight: '#fc6',
            
            // ì•„ì´í…œ
            coinGold: '#ffd700',
            coinLight: '#ffed70',
            coinDark: '#c9a000',
            gemBlue: '#4af',
            gemLight: '#8cf',
            gemDark: '#28d',
            gemPurple: '#a4f',
            gemPurpleLight: '#c8f',
            
            // ë°°ê²½
            bgDark: '#12121a',
            bgMid: '#1a1a24',
            torch: '#f94',
            torchGlow: 'rgba(255,150,50,0.3)'
        };
        
        // ============================================
        // ìŠ¤í”„ë¼ì´íŠ¸ ìºì‹œ (ì˜¤í”„ìŠ¤í¬ë¦° ìº”ë²„ìŠ¤)
        // ============================================
        const spriteCache = {};
        
        function createSprite(name, width, height, drawFn) {
            const offscreen = document.createElement('canvas');
            offscreen.width = width;
            offscreen.height = height;
            const octx = offscreen.getContext('2d');
            octx.imageSmoothingEnabled = false;
            drawFn(octx, width, height);
            spriteCache[name] = offscreen;
            return offscreen;
        }
        
        // í”½ì…€ ê·¸ë¦¬ê¸° í—¬í¼
        function drawPixel(ctx, x, y, color, size = 1) {
            ctx.fillStyle = color;
            ctx.fillRect(x * PIXEL_SCALE, y * PIXEL_SCALE, size * PIXEL_SCALE, size * PIXEL_SCALE);
        }
        
        function drawPixelRect(ctx, x, y, w, h, color) {
            ctx.fillStyle = color;
            ctx.fillRect(x * PIXEL_SCALE, y * PIXEL_SCALE, w * PIXEL_SCALE, h * PIXEL_SCALE);
        }
        
        // ============================================
        // ìºë¦­í„° ìŠ¤í”„ë¼ì´íŠ¸ ìƒì„± (ë‹¬ë¦¬ê¸° ì• ë‹ˆë©”ì´ì…˜)
        // ============================================
        function createPlayerSprites() {
            // ê° í”„ë ˆì„ í¬ê¸°: 20x26 í”½ì…€
            const W = 20, H = 26;
            
            // ëŸ° í”„ë ˆì„ 1
            createSprite('player_run1', W * PIXEL_SCALE, H * PIXEL_SCALE, (ctx) => {
                // ë§í† 
                drawPixelRect(ctx, 5, 8, 4, 12, PALETTE.cape);
                drawPixelRect(ctx, 4, 10, 2, 8, PALETTE.capeDark);
                
                // ëª¸í†µ (ê°‘ì˜·)
                drawPixelRect(ctx, 7, 8, 7, 10, PALETTE.armor);
                drawPixelRect(ctx, 8, 8, 5, 2, PALETTE.armorLight);
                drawPixelRect(ctx, 7, 16, 7, 2, PALETTE.armorDark);
                
                // ë¨¸ë¦¬
                drawPixelRect(ctx, 8, 1, 6, 7, PALETTE.skin);
                drawPixelRect(ctx, 9, 0, 4, 2, PALETTE.hair);
                drawPixelRect(ctx, 8, 1, 2, 3, PALETTE.hair);
                
                // ëˆˆ
                drawPixel(ctx, 12, 3, '#333', 1);
                drawPixel(ctx, 12, 4, '#fff', 1);
                
                // íŒ”
                drawPixelRect(ctx, 14, 9, 3, 6, PALETTE.armor);
                drawPixelRect(ctx, 5, 9, 2, 5, PALETTE.armor);
                
                // ë‹¤ë¦¬ (ë‹¬ë¦¬ê¸° í¬ì¦ˆ 1)
                drawPixelRect(ctx, 8, 18, 3, 6, PALETTE.armorDark);
                drawPixelRect(ctx, 12, 18, 3, 4, PALETTE.armorDark);
                
                // ë¶€ì¸ 
                drawPixelRect(ctx, 7, 23, 4, 3, PALETTE.brickDark);
                drawPixelRect(ctx, 12, 21, 4, 2, PALETTE.brickDark);
            });
            
            // ëŸ° í”„ë ˆì„ 2
            createSprite('player_run2', W * PIXEL_SCALE, H * PIXEL_SCALE, (ctx) => {
                // ë§í†  (í„ëŸ­ì„)
                drawPixelRect(ctx, 4, 8, 4, 10, PALETTE.cape);
                drawPixelRect(ctx, 3, 9, 2, 7, PALETTE.capeDark);
                drawPixelRect(ctx, 2, 11, 2, 5, PALETTE.cape);
                
                // ëª¸í†µ
                drawPixelRect(ctx, 7, 8, 7, 10, PALETTE.armor);
                drawPixelRect(ctx, 8, 8, 5, 2, PALETTE.armorLight);
                drawPixelRect(ctx, 7, 16, 7, 2, PALETTE.armorDark);
                
                // ë¨¸ë¦¬
                drawPixelRect(ctx, 8, 1, 6, 7, PALETTE.skin);
                drawPixelRect(ctx, 9, 0, 4, 2, PALETTE.hair);
                drawPixelRect(ctx, 8, 1, 2, 3, PALETTE.hair);
                
                // ëˆˆ
                drawPixel(ctx, 12, 3, '#333', 1);
                drawPixel(ctx, 12, 4, '#fff', 1);
                
                // íŒ” (ì•ìœ¼ë¡œ)
                drawPixelRect(ctx, 14, 8, 4, 5, PALETTE.armor);
                drawPixelRect(ctx, 4, 10, 2, 4, PALETTE.armor);
                
                // ë‹¤ë¦¬ (ë‹¬ë¦¬ê¸° í¬ì¦ˆ 2)
                drawPixelRect(ctx, 9, 18, 3, 4, PALETTE.armorDark);
                drawPixelRect(ctx, 11, 18, 3, 6, PALETTE.armorDark);
                
                // ë¶€ì¸ 
                drawPixelRect(ctx, 8, 21, 4, 2, PALETTE.brickDark);
                drawPixelRect(ctx, 11, 23, 4, 3, PALETTE.brickDark);
            });
            
            // ëŸ° í”„ë ˆì„ 3
            createSprite('player_run3', W * PIXEL_SCALE, H * PIXEL_SCALE, (ctx) => {
                // ë§í† 
                drawPixelRect(ctx, 5, 8, 4, 11, PALETTE.cape);
                drawPixelRect(ctx, 4, 10, 2, 7, PALETTE.capeDark);
                
                // ëª¸í†µ
                drawPixelRect(ctx, 7, 8, 7, 10, PALETTE.armor);
                drawPixelRect(ctx, 8, 8, 5, 2, PALETTE.armorLight);
                drawPixelRect(ctx, 7, 16, 7, 2, PALETTE.armorDark);
                
                // ë¨¸ë¦¬
                drawPixelRect(ctx, 8, 1, 6, 7, PALETTE.skin);
                drawPixelRect(ctx, 9, 0, 4, 2, PALETTE.hair);
                drawPixelRect(ctx, 8, 1, 2, 3, PALETTE.hair);
                
                // ëˆˆ
                drawPixel(ctx, 12, 3, '#333', 1);
                drawPixel(ctx, 12, 4, '#fff', 1);
                
                // íŒ” (ì¤‘ê°„)
                drawPixelRect(ctx, 14, 9, 3, 5, PALETTE.armor);
                drawPixelRect(ctx, 5, 9, 2, 5, PALETTE.armor);
                
                // ë‹¤ë¦¬ (ì¤‘ê°„ í¬ì¦ˆ)
                drawPixelRect(ctx, 8, 18, 3, 5, PALETTE.armorDark);
                drawPixelRect(ctx, 11, 18, 3, 5, PALETTE.armorDark);
                
                // ë¶€ì¸ 
                drawPixelRect(ctx, 7, 22, 4, 3, PALETTE.brickDark);
                drawPixelRect(ctx, 11, 22, 4, 3, PALETTE.brickDark);
            });
            
            // ëŸ° í”„ë ˆì„ 4
            createSprite('player_run4', W * PIXEL_SCALE, H * PIXEL_SCALE, (ctx) => {
                // ë§í†  (í„ëŸ­ì„ ë°˜ëŒ€)
                drawPixelRect(ctx, 4, 8, 5, 11, PALETTE.cape);
                drawPixelRect(ctx, 3, 10, 2, 8, PALETTE.capeDark);
                drawPixelRect(ctx, 2, 12, 2, 6, PALETTE.cape);
                
                // ëª¸í†µ
                drawPixelRect(ctx, 7, 8, 7, 10, PALETTE.armor);
                drawPixelRect(ctx, 8, 8, 5, 2, PALETTE.armorLight);
                drawPixelRect(ctx, 7, 16, 7, 2, PALETTE.armorDark);
                
                // ë¨¸ë¦¬
                drawPixelRect(ctx, 8, 1, 6, 7, PALETTE.skin);
                drawPixelRect(ctx, 9, 0, 4, 2, PALETTE.hair);
                drawPixelRect(ctx, 8, 1, 2, 3, PALETTE.hair);
                
                // ëˆˆ
                drawPixel(ctx, 12, 3, '#333', 1);
                drawPixel(ctx, 12, 4, '#fff', 1);
                
                // íŒ” (ë’¤ë¡œ)
                drawPixelRect(ctx, 14, 10, 3, 5, PALETTE.armor);
                drawPixelRect(ctx, 4, 8, 2, 5, PALETTE.armor);
                
                // ë‹¤ë¦¬ (ë°˜ëŒ€ ë‹¬ë¦¬ê¸°)
                drawPixelRect(ctx, 12, 18, 3, 6, PALETTE.armorDark);
                drawPixelRect(ctx, 8, 18, 3, 4, PALETTE.armorDark);
                
                // ë¶€ì¸ 
                drawPixelRect(ctx, 12, 23, 4, 3, PALETTE.brickDark);
                drawPixelRect(ctx, 7, 21, 4, 2, PALETTE.brickDark);
            });
            
            // ì í”„ ìŠ¤í”„ë¼ì´íŠ¸
            createSprite('player_jump', W * PIXEL_SCALE, H * PIXEL_SCALE, (ctx) => {
                // ë§í†  (ìœ„ë¡œ í„ëŸ­ì„)
                drawPixelRect(ctx, 4, 10, 4, 14, PALETTE.cape);
                drawPixelRect(ctx, 3, 12, 2, 10, PALETTE.capeDark);
                drawPixelRect(ctx, 2, 14, 2, 8, PALETTE.cape);
                
                // ëª¸í†µ
                drawPixelRect(ctx, 7, 6, 7, 10, PALETTE.armor);
                drawPixelRect(ctx, 8, 6, 5, 2, PALETTE.armorLight);
                
                // ë¨¸ë¦¬
                drawPixelRect(ctx, 8, 0, 6, 7, PALETTE.skin);
                drawPixelRect(ctx, 9, 0, 4, 2, PALETTE.hair);
                drawPixelRect(ctx, 8, 0, 2, 3, PALETTE.hair);
                
                // ëˆˆ (ìœ„ ë´„)
                drawPixel(ctx, 12, 2, '#333', 1);
                drawPixel(ctx, 12, 3, '#fff', 1);
                
                // íŒ” (ìœ„ë¡œ)
                drawPixelRect(ctx, 14, 4, 4, 5, PALETTE.armor);
                drawPixelRect(ctx, 4, 6, 3, 5, PALETTE.armor);
                
                // ë‹¤ë¦¬ (ëª¨ìŒ)
                drawPixelRect(ctx, 8, 16, 6, 5, PALETTE.armorDark);
                
                // ë¶€ì¸ 
                drawPixelRect(ctx, 8, 20, 3, 3, PALETTE.brickDark);
                drawPixelRect(ctx, 12, 20, 3, 3, PALETTE.brickDark);
            });
        }
        
        // ============================================
        // ì¥ì• ë¬¼ ìŠ¤í”„ë¼ì´íŠ¸ ìƒì„±
        // ============================================
        function createObstacleSprites() {
            // ê°€ì‹œ (16x16)
            createSprite('spike', 16 * PIXEL_SCALE, 16 * PIXEL_SCALE, (ctx) => {
                // ë² ì´ìŠ¤
                drawPixelRect(ctx, 1, 14, 14, 2, PALETTE.stoneDark);
                // ê°€ì‹œë“¤
                for (let i = 0; i < 3; i++) {
                    const x = 2 + i * 5;
                    drawPixel(ctx, x + 2, 4 + i % 2, PALETTE.spikeLight, 1);
                    drawPixel(ctx, x + 1, 6, PALETTE.spike, 1);
                    drawPixel(ctx, x + 2, 6, PALETTE.spikeLight, 1);
                    drawPixel(ctx, x + 3, 6, PALETTE.spike, 1);
                    drawPixelRect(ctx, x, 8, 5, 2, PALETTE.spike);
                    drawPixelRect(ctx, x, 10, 5, 4, PALETTE.stoneDark);
                }
            });
            
            // ìŠ¬ë¼ì„ ëª¬ìŠ¤í„° (20x16)
            createSprite('slime', 20 * PIXEL_SCALE, 16 * PIXEL_SCALE, (ctx) => {
                // ëª¸ì²´
                drawPixelRect(ctx, 3, 6, 14, 8, PALETTE.monster);
                drawPixelRect(ctx, 5, 4, 10, 4, PALETTE.monster);
                drawPixelRect(ctx, 4, 5, 12, 2, PALETTE.monsterLight);
                drawPixelRect(ctx, 2, 10, 16, 4, PALETTE.monster);
                // í•˜ì´ë¼ì´íŠ¸
                drawPixelRect(ctx, 6, 5, 3, 2, '#a87aa8');
                // ëˆˆ
                drawPixelRect(ctx, 6, 7, 3, 3, '#fff');
                drawPixelRect(ctx, 12, 7, 3, 3, '#fff');
                drawPixel(ctx, 7, 8, '#000', 2);
                drawPixel(ctx, 13, 8, '#000', 2);
                // ì…
                drawPixelRect(ctx, 8, 11, 4, 2, '#000');
            });
            
            // ë°•ì¥ (24x16)
            createSprite('bat1', 24 * PIXEL_SCALE, 16 * PIXEL_SCALE, (ctx) => {
                // ë‚ ê°œ í¼ì¹¨
                drawPixelRect(ctx, 0, 4, 6, 6, PALETTE.batWing);
                drawPixelRect(ctx, 18, 4, 6, 6, PALETTE.batWing);
                drawPixelRect(ctx, 2, 2, 4, 4, PALETTE.batWing);
                drawPixelRect(ctx, 18, 2, 4, 4, PALETTE.batWing);
                // ëª¸ì²´
                drawPixelRect(ctx, 9, 4, 6, 8, PALETTE.bat);
                drawPixelRect(ctx, 10, 3, 4, 2, PALETTE.bat);
                // ëˆˆ
                drawPixel(ctx, 10, 5, PALETTE.monsterEye, 2);
                drawPixel(ctx, 13, 5, PALETTE.monsterEye, 2);
                // ê·€
                drawPixel(ctx, 9, 2, PALETTE.bat, 1);
                drawPixel(ctx, 14, 2, PALETTE.bat, 1);
            });
            
            createSprite('bat2', 24 * PIXEL_SCALE, 16 * PIXEL_SCALE, (ctx) => {
                // ë‚ ê°œ ì ‘ìŒ
                drawPixelRect(ctx, 4, 6, 4, 8, PALETTE.batWing);
                drawPixelRect(ctx, 16, 6, 4, 8, PALETTE.batWing);
                // ëª¸ì²´
                drawPixelRect(ctx, 9, 4, 6, 8, PALETTE.bat);
                drawPixelRect(ctx, 10, 3, 4, 2, PALETTE.bat);
                // ëˆˆ
                drawPixel(ctx, 10, 5, PALETTE.monsterEye, 2);
                drawPixel(ctx, 13, 5, PALETTE.monsterEye, 2);
                // ê·€
                drawPixel(ctx, 9, 2, PALETTE.bat, 1);
                drawPixel(ctx, 14, 2, PALETTE.bat, 1);
            });
            
            // í™”ì—¼ íŠ¸ë© (16x20)
            createSprite('fire1', 16 * PIXEL_SCALE, 20 * PIXEL_SCALE, (ctx) => {
                // ë² ì´ìŠ¤
                drawPixelRect(ctx, 2, 16, 12, 4, PALETTE.stoneDark);
                drawPixelRect(ctx, 4, 14, 8, 2, PALETTE.brickDark);
                // ë¶ˆê½ƒ
                drawPixelRect(ctx, 5, 6, 6, 8, PALETTE.fire);
                drawPixelRect(ctx, 6, 4, 4, 4, PALETTE.fire);
                drawPixelRect(ctx, 7, 2, 2, 4, PALETTE.fireLight);
                drawPixelRect(ctx, 6, 8, 4, 4, PALETTE.fireLight);
                // ë¶ˆê½ƒ íŒ
                drawPixel(ctx, 4, 10, PALETTE.fire, 2);
                drawPixel(ctx, 10, 8, PALETTE.fire, 2);
            });
            
            createSprite('fire2', 16 * PIXEL_SCALE, 20 * PIXEL_SCALE, (ctx) => {
                // ë² ì´ìŠ¤
                drawPixelRect(ctx, 2, 16, 12, 4, PALETTE.stoneDark);
                drawPixelRect(ctx, 4, 14, 8, 2, PALETTE.brickDark);
                // ë¶ˆê½ƒ (ë‹¤ë¥¸ ëª¨ì–‘)
                drawPixelRect(ctx, 5, 4, 6, 10, PALETTE.fire);
                drawPixelRect(ctx, 6, 2, 4, 4, PALETTE.fire);
                drawPixelRect(ctx, 7, 0, 2, 4, PALETTE.fireLight);
                drawPixelRect(ctx, 6, 6, 4, 6, PALETTE.fireLight);
                // ë¶ˆê½ƒ íŒ
                drawPixel(ctx, 10, 6, PALETTE.fire, 2);
                drawPixel(ctx, 3, 8, PALETTE.fire, 2);
            });
        }
        
        // ============================================
        // ì•„ì´í…œ ìŠ¤í”„ë¼ì´íŠ¸ ìƒì„±
        // ============================================
        function createItemSprites() {
            // ì½”ì¸ (12x12)
            createSprite('coin1', 12 * PIXEL_SCALE, 12 * PIXEL_SCALE, (ctx) => {
                drawPixelRect(ctx, 2, 1, 8, 10, PALETTE.coinGold);
                drawPixelRect(ctx, 3, 0, 6, 1, PALETTE.coinGold);
                drawPixelRect(ctx, 3, 11, 6, 1, PALETTE.coinGold);
                drawPixelRect(ctx, 3, 2, 2, 6, PALETTE.coinLight);
                drawPixelRect(ctx, 7, 4, 2, 4, PALETTE.coinDark);
                // $ ì‹¬ë³¼
                drawPixelRect(ctx, 5, 2, 2, 8, PALETTE.coinDark);
            });
            
            createSprite('coin2', 12 * PIXEL_SCALE, 12 * PIXEL_SCALE, (ctx) => {
                drawPixelRect(ctx, 3, 1, 6, 10, PALETTE.coinGold);
                drawPixelRect(ctx, 4, 0, 4, 1, PALETTE.coinGold);
                drawPixelRect(ctx, 4, 11, 4, 1, PALETTE.coinGold);
                drawPixelRect(ctx, 4, 2, 2, 6, PALETTE.coinLight);
                // íšŒì „ íš¨ê³¼
                drawPixelRect(ctx, 5, 2, 2, 8, PALETTE.coinDark);
            });
            
            createSprite('coin3', 12 * PIXEL_SCALE, 12 * PIXEL_SCALE, (ctx) => {
                drawPixelRect(ctx, 4, 1, 4, 10, PALETTE.coinGold);
                drawPixelRect(ctx, 5, 0, 2, 1, PALETTE.coinGold);
                drawPixelRect(ctx, 5, 11, 2, 1, PALETTE.coinGold);
                drawPixelRect(ctx, 5, 3, 1, 6, PALETTE.coinLight);
            });
            
            createSprite('coin4', 12 * PIXEL_SCALE, 12 * PIXEL_SCALE, (ctx) => {
                drawPixelRect(ctx, 5, 1, 2, 10, PALETTE.coinDark);
                drawPixelRect(ctx, 5, 0, 2, 1, PALETTE.coinDark);
                drawPixelRect(ctx, 5, 11, 2, 1, PALETTE.coinDark);
            });
            
            // ë³´ì„ (14x14)
            createSprite('gem', 14 * PIXEL_SCALE, 14 * PIXEL_SCALE, (ctx) => {
                // ë‹¤ì´ì•„ëª¬ë“œ í˜•íƒœ
                drawPixelRect(ctx, 5, 0, 4, 2, PALETTE.gemLight);
                drawPixelRect(ctx, 3, 2, 8, 3, PALETTE.gemBlue);
                drawPixelRect(ctx, 4, 2, 2, 2, PALETTE.gemLight);
                drawPixelRect(ctx, 1, 5, 12, 4, PALETTE.gemBlue);
                drawPixelRect(ctx, 2, 5, 4, 2, PALETTE.gemLight);
                drawPixelRect(ctx, 2, 9, 10, 2, PALETTE.gemBlue);
                drawPixelRect(ctx, 3, 11, 8, 1, PALETTE.gemDark);
                drawPixelRect(ctx, 4, 12, 6, 1, PALETTE.gemDark);
                drawPixelRect(ctx, 5, 13, 4, 1, PALETTE.gemDark);
                // ë°˜ì§ì„
                drawPixel(ctx, 3, 3, '#fff', 2);
            });
            
            // ìŠ¤íƒ€ (16x16)
            createSprite('star', 16 * PIXEL_SCALE, 16 * PIXEL_SCALE, (ctx) => {
                const gold = '#ffd700';
                const light = '#ffed70';
                const dark = '#c9a000';
                // ë³„ ëª¨ì–‘
                drawPixelRect(ctx, 7, 0, 2, 4, light);
                drawPixelRect(ctx, 6, 4, 4, 2, gold);
                drawPixelRect(ctx, 0, 6, 16, 4, gold);
                drawPixelRect(ctx, 2, 6, 3, 2, light);
                drawPixelRect(ctx, 5, 10, 6, 2, gold);
                drawPixelRect(ctx, 3, 12, 4, 2, dark);
                drawPixelRect(ctx, 9, 12, 4, 2, dark);
                drawPixelRect(ctx, 2, 14, 3, 2, dark);
                drawPixelRect(ctx, 11, 14, 3, 2, dark);
                // ë°˜ì§ì„
                drawPixel(ctx, 7, 1, '#fff', 2);
            });
        }
        
        // ============================================
        // ë°°ê²½ ìŠ¤í”„ë¼ì´íŠ¸ ìƒì„±
        // ============================================
        function createBackgroundSprites() {
            // ë˜ì „ ë²½ëŒ íƒ€ì¼ (32x32)
            createSprite('wall', 32 * PIXEL_SCALE, 32 * PIXEL_SCALE, (ctx) => {
                ctx.fillStyle = PALETTE.brick;
                ctx.fillRect(0, 0, 32 * PIXEL_SCALE, 32 * PIXEL_SCALE);
                
                // ë²½ëŒ íŒ¨í„´
                for (let row = 0; row < 4; row++) {
                    const offset = row % 2 === 0 ? 0 : 8;
                    for (let col = 0; col < 3; col++) {
                        const x = col * 16 + offset - 8;
                        const y = row * 8;
                        // ë²½ëŒ ê·¸ë¦¼ì
                        drawPixelRect(ctx, x, y, 15, 7, PALETTE.brickDark);
                        drawPixelRect(ctx, x + 1, y + 1, 13, 5, PALETTE.brick);
                        // í•˜ì´ë¼ì´íŠ¸
                        drawPixelRect(ctx, x + 1, y + 1, 6, 2, '#6a5a4a');
                    }
                }
            });
            
            // ë°”ë‹¥ íƒ€ì¼ (32x16)
            createSprite('floor', 32 * PIXEL_SCALE, 16 * PIXEL_SCALE, (ctx) => {
                ctx.fillStyle = PALETTE.stone;
                ctx.fillRect(0, 0, 32 * PIXEL_SCALE, 16 * PIXEL_SCALE);
                
                // ëŒ íŒ¨í„´
                drawPixelRect(ctx, 0, 0, 32, 2, PALETTE.stoneLight);
                for (let i = 0; i < 4; i++) {
                    const x = i * 8;
                    drawPixelRect(ctx, x, 2, 1, 14, PALETTE.stoneDark);
                    // ê· ì—´
                    if (i % 2 === 0) {
                        drawPixel(ctx, x + 3, 6, PALETTE.stoneDark, 1);
                        drawPixel(ctx, x + 4, 7, PALETTE.stoneDark, 1);
                        drawPixel(ctx, x + 4, 8, PALETTE.stoneDark, 1);
                    }
                }
            });
            
            // íšƒë¶ˆ (8x16)
            createSprite('torch1', 8 * PIXEL_SCALE, 16 * PIXEL_SCALE, (ctx) => {
                // ì†ì¡ì´
                drawPixelRect(ctx, 3, 8, 2, 8, PALETTE.brickDark);
                // ë¶ˆê½ƒ
                drawPixelRect(ctx, 2, 2, 4, 6, PALETTE.fire);
                drawPixelRect(ctx, 3, 0, 2, 4, PALETTE.fireLight);
                drawPixel(ctx, 2, 4, PALETTE.fireLight, 2);
            });
            
            createSprite('torch2', 8 * PIXEL_SCALE, 16 * PIXEL_SCALE, (ctx) => {
                // ì†ì¡ì´
                drawPixelRect(ctx, 3, 8, 2, 8, PALETTE.brickDark);
                // ë¶ˆê½ƒ (ë‹¤ë¥¸ ëª¨ì–‘)
                drawPixelRect(ctx, 2, 3, 4, 5, PALETTE.fire);
                drawPixelRect(ctx, 3, 1, 2, 4, PALETTE.fireLight);
                drawPixel(ctx, 5, 3, PALETTE.fireLight, 1);
                drawPixel(ctx, 1, 5, PALETTE.fire, 1);
            });
            
            // í•´ê³¨ ì¥ì‹ (12x12)
            createSprite('skull', 12 * PIXEL_SCALE, 12 * PIXEL_SCALE, (ctx) => {
                drawPixelRect(ctx, 2, 2, 8, 6, '#eee');
                drawPixelRect(ctx, 3, 0, 6, 3, '#eee');
                drawPixelRect(ctx, 3, 8, 6, 2, '#eee');
                // ëˆˆêµ¬ë©
                drawPixelRect(ctx, 3, 3, 2, 2, '#222');
                drawPixelRect(ctx, 7, 3, 2, 2, '#222');
                // ì½”
                drawPixel(ctx, 5, 5, '#222', 2);
                // ì´ë¹¨
                drawPixel(ctx, 4, 8, '#222', 1);
                drawPixel(ctx, 6, 8, '#222', 1);
            });
            
            // ì‚¬ìŠ¬ (4x20)
            createSprite('chain', 4 * PIXEL_SCALE, 20 * PIXEL_SCALE, (ctx) => {
                for (let i = 0; i < 5; i++) {
                    const y = i * 4;
                    drawPixelRect(ctx, 1, y, 2, 3, PALETTE.stoneLight);
                    drawPixelRect(ctx, 0, y + 1, 1, 1, PALETTE.stoneLight);
                    drawPixelRect(ctx, 3, y + 1, 1, 1, PALETTE.stoneLight);
                }
            });
        }
        
        // ëª¨ë“  ìŠ¤í”„ë¼ì´íŠ¸ ì´ˆê¸°í™”
        function initSprites() {
            createPlayerSprites();
            createObstacleSprites();
            createItemSprites();
            createBackgroundSprites();
        }
        
        // ê²Œì„ ìƒíƒœ
        let gameState = 'start';
        let score = 0;
        let coins = 0;
        let speed = 5;
        let frameCount = 0;
        
        // í”Œë ˆì´ì–´
        const player = {
            x: 100,
            y: 300,
            width: 40,
            height: 52,
            vy: 0,
            jumping: false,
            grounded: true,
            jumpPower: -14,
            gravity: 0.6,
            runFrame: 0,
            animTimer: 0
        };
        
        // ì§€ë©´
        const ground = {
            y: 350,
            height: 50
        };
        
        // ì¥ì• ë¬¼ & ì•„ì´í…œ
        let obstacles = [];
        let collectibles = [];
        let particles = [];
        let bgElements = [];
        let torches = [];
        let parallaxBg = [];
        
        // ì¥ì• ë¬¼ íƒ€ì…
        const obstacleTypes = [
            { type: 'spike', sprite: 'spike', width: 32, height: 32, yOffset: -32 },
            { type: 'slime', sprite: 'slime', width: 40, height: 32, yOffset: -32 },
            { type: 'bat', sprite: 'bat1', width: 48, height: 32, yOffset: -80, flying: true },
            { type: 'fire', sprite: 'fire1', width: 32, height: 40, yOffset: -40 }
        ];
        
        // ìˆ˜ì§‘ ì•„ì´í…œ
        const collectibleTypes = [
            { type: 'coin', sprite: 'coin1', value: 1, frames: 4 },
            { type: 'gem', sprite: 'gem', value: 5, frames: 1 },
            { type: 'star', sprite: 'star', value: 10, frames: 1 }
        ];
        
        // ë°°ê²½ ì´ˆê¸°í™”
        function initBackground() {
            bgElements = [];
            torches = [];
            parallaxBg = [];
            
            // íŒ¨ëŸ´ë ‰ìŠ¤ ë°°ê²½ ë ˆì´ì–´
            for (let i = 0; i < 3; i++) {
                parallaxBg.push({
                    offset: 0,
                    speed: 0.5 + i * 0.5,
                    y: 100 + i * 60,
                    elements: []
                });
                
                // ê° ë ˆì´ì–´ì— ì¥ì‹ ìš”ì†Œ ì¶”ê°€
                for (let j = 0; j < 5; j++) {
                    parallaxBg[i].elements.push({
                        x: j * 200 + Math.random() * 100,
                        type: ['skull', 'chain'][Math.floor(Math.random() * 2)],
                        scale: 0.5 + i * 0.3
                    });
                }
            }
            
            // íšƒë¶ˆ ë°°ì¹˜
            for (let i = 0; i < 6; i++) {
                torches.push({
                    x: i * 150 + 50,
                    y: 200,
                    frame: Math.random() > 0.5 ? 0 : 1,
                    timer: Math.random() * 10
                });
            }
        }
        
        // ì¥ì• ë¬¼ ìƒì„±
        function spawnObstacle() {
            const typeData = obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];
            const y = typeData.flying ? ground.y - 80 : ground.y + typeData.yOffset;
            
            obstacles.push({
                ...typeData,
                x: BASE_WIDTH + 50,
                y: y,
                passed: false,
                animFrame: 0,
                animTimer: 0
            });
        }
        
        // ìˆ˜ì§‘ ì•„ì´í…œ ìƒì„±
        function spawnCollectible() {
            const typeData = collectibleTypes[Math.floor(Math.random() * collectibleTypes.length)];
            const y = ground.y - 60 - Math.random() * 80;
            
            collectibles.push({
                ...typeData,
                x: BASE_WIDTH + 50,
                y: y,
                size: 28,
                collected: false,
                bobOffset: Math.random() * Math.PI * 2,
                animFrame: 0,
                animTimer: 0
            });
        }
        
        // íŒŒí‹°í´ ìƒì„±
        function createParticle(x, y, color, count = 8) {
            for (let i = 0; i < count; i++) {
                particles.push({
                    x, y,
                    vx: (Math.random() - 0.5) * 6,
                    vy: (Math.random() - 0.8) * 6,
                    life: 40,
                    color: color,
                    size: 2 + Math.random() * 4
                });
            }
        }
        
        // ì í”„
        function jump() {
            if (player.grounded && gameState === 'playing') {
                player.vy = player.jumpPower;
                player.jumping = true;
                player.grounded = false;
                createParticle(player.x + player.width/2, player.y + player.height, PALETTE.stone, 5);
            }
        }
        
        // ì¶©ëŒ ê°ì§€
        function checkCollision(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }
        
        // ê²Œì„ ì—…ë°ì´íŠ¸
        function update() {
            if (gameState !== 'playing') return;
            
            frameCount++;
            
            // ì†ë„ ì¦ê°€
            if (frameCount % 500 === 0) {
                speed = Math.min(speed + 0.5, 12);
            }
            
            // ì ìˆ˜ ì¦ê°€
            score = Math.floor(frameCount / 5);
            
            // í”Œë ˆì´ì–´ ë¬¼ë¦¬
            player.vy += player.gravity;
            player.y += player.vy;
            
            if (player.y + player.height >= ground.y) {
                player.y = ground.y - player.height;
                player.vy = 0;
                player.grounded = true;
                player.jumping = false;
            }
            
            // í”Œë ˆì´ì–´ ì• ë‹ˆë©”ì´ì…˜
            if (player.grounded) {
                player.animTimer++;
                if (player.animTimer >= 6) {
                    player.animTimer = 0;
                    player.runFrame = (player.runFrame + 1) % 4;
                }
            }
            
            // íšƒë¶ˆ ì• ë‹ˆë©”ì´ì…˜
            torches.forEach(torch => {
                torch.timer++;
                if (torch.timer >= 8) {
                    torch.timer = 0;
                    torch.frame = 1 - torch.frame;
                }
                torch.x -= speed * 0.3;
                if (torch.x < -20) {
                    torch.x += BASE_WIDTH + 100;
                }
            });
            
            // íŒ¨ëŸ´ë ‰ìŠ¤ ë°°ê²½ ì—…ë°ì´íŠ¸
            parallaxBg.forEach(layer => {
                layer.offset += layer.speed;
                if (layer.offset >= 200) {
                    layer.offset = 0;
                }
            });
            
            // ì¥ì• ë¬¼ ìŠ¤í°
            if (frameCount % Math.max(70, 130 - Math.floor(speed * 4)) === 0) {
                spawnObstacle();
            }
            
            // ìˆ˜ì§‘ ì•„ì´í…œ ìŠ¤í°
            if (frameCount % 90 === 0) {
                spawnCollectible();
            }
            
            // ì¥ì• ë¬¼ ì—…ë°ì´íŠ¸
            obstacles = obstacles.filter(obs => {
                obs.x -= speed;
                obs.animTimer++;
                
                // ì• ë‹ˆë©”ì´ì…˜ (ë°•ì¥, í™”ì—¼)
                if (obs.animTimer >= 8) {
                    obs.animTimer = 0;
                    obs.animFrame = 1 - obs.animFrame;
                }
                
                // ì¶©ëŒ ì²´í¬
                const playerRect = {
                    x: player.x + 8,
                    y: player.y + 4,
                    width: player.width - 16,
                    height: player.height - 8
                };
                
                const obsRect = {
                    x: obs.x + 4,
                    y: obs.y + 4,
                    width: obs.width - 8,
                    height: obs.height - 8
                };
                
                if (checkCollision(playerRect, obsRect)) {
                    gameOver();
                }
                
                return obs.x > -100;
            });
            
            // ìˆ˜ì§‘ ì•„ì´í…œ ì—…ë°ì´íŠ¸
            collectibles = collectibles.filter(item => {
                item.x -= speed;
                item.bobOffset += 0.08;
                item.animTimer++;
                
                // ì½”ì¸ ì• ë‹ˆë©”ì´ì…˜
                if (item.type === 'coin' && item.animTimer >= 6) {
                    item.animTimer = 0;
                    item.animFrame = (item.animFrame + 1) % 4;
                }
                
                const bobY = item.y + Math.sin(item.bobOffset) * 5;
                
                const playerRect = {
                    x: player.x,
                    y: player.y,
                    width: player.width,
                    height: player.height
                };
                
                const itemRect = {
                    x: item.x,
                    y: bobY,
                    width: item.size,
                    height: item.size
                };
                
                if (!item.collected && checkCollision(playerRect, itemRect)) {
                    item.collected = true;
                    coins += item.value;
                    createParticle(item.x + item.size/2, bobY + item.size/2, 
                        item.type === 'coin' ? PALETTE.coinGold : 
                        item.type === 'gem' ? PALETTE.gemBlue : PALETTE.coinGold, 10);
                }
                
                return item.x > -50 && !item.collected;
            });
            
            // íŒŒí‹°í´ ì—…ë°ì´íŠ¸
            particles = particles.filter(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.2;
                p.life--;
                return p.life > 0;
            });
            
            // UI ì—…ë°ì´íŠ¸
            document.getElementById('score').textContent = `âš”ï¸ ${score}m`;
            document.getElementById('coins').textContent = `ğŸ’ ${coins}`;
        }
        
        // ê·¸ë¦¬ê¸°
        function draw() {
            // ë°°ê²½ ê·¸ë¼ë°ì´ì…˜
            const gradient = ctx.createLinearGradient(0, 0, 0, BASE_HEIGHT);
            gradient.addColorStop(0, PALETTE.bgDark);
            gradient.addColorStop(0.5, PALETTE.bgMid);
            gradient.addColorStop(1, '#0a0a10');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, BASE_WIDTH, BASE_HEIGHT);
            
            // íŒ¨ëŸ´ë ‰ìŠ¤ ë°°ê²½
            ctx.globalAlpha = 0.3;
            parallaxBg.forEach((layer, idx) => {
                layer.elements.forEach(el => {
                    const x = ((el.x - layer.offset) % (BASE_WIDTH + 200)) - 50;
                    if (spriteCache[el.type]) {
                        const scale = el.scale;
                        ctx.drawImage(spriteCache[el.type], x, layer.y, 
                            spriteCache[el.type].width * scale, 
                            spriteCache[el.type].height * scale);
                    }
                });
            });
            ctx.globalAlpha = 1;
            
            // íšƒë¶ˆ ë° ì¡°ëª… íš¨ê³¼
            torches.forEach(torch => {
                // ì¡°ëª… ê¸€ë¡œìš°
                const grd = ctx.createRadialGradient(torch.x + 8, torch.y + 8, 0, torch.x + 8, torch.y + 8, 80);
                grd.addColorStop(0, 'rgba(255,150,50,0.15)');
                grd.addColorStop(1, 'rgba(255,150,50,0)');
                ctx.fillStyle = grd;
                ctx.fillRect(torch.x - 70, torch.y - 70, 160, 160);
                
                // íšƒë¶ˆ ìŠ¤í”„ë¼ì´íŠ¸
                const torchSprite = torch.frame === 0 ? 'torch1' : 'torch2';
                if (spriteCache[torchSprite]) {
                    ctx.drawImage(spriteCache[torchSprite], torch.x, torch.y);
                }
            });
            
            // ì§€ë©´ (íƒ€ì¼ íŒ¨í„´)
            if (spriteCache.floor) {
                for (let i = -1; i < Math.ceil(BASE_WIDTH / 64) + 1; i++) {
                    const offsetX = (frameCount * speed * 0.5) % 64;
                    ctx.drawImage(spriteCache.floor, i * 64 - offsetX, ground.y);
                }
            }
            
            // ë²½ í…ìŠ¤ì²˜ (ìƒë‹¨)
            ctx.fillStyle = PALETTE.stoneDark;
            ctx.fillRect(0, 0, BASE_WIDTH, 30);
            
            // ì¥ì• ë¬¼
            obstacles.forEach(obs => {
                let spriteName = obs.sprite;
                
                // ì• ë‹ˆë©”ì´ì…˜ í”„ë ˆì„ ì„ íƒ
                if (obs.type === 'bat') {
                    spriteName = obs.animFrame === 0 ? 'bat1' : 'bat2';
                } else if (obs.type === 'fire') {
                    spriteName = obs.animFrame === 0 ? 'fire1' : 'fire2';
                }
                
                if (spriteCache[spriteName]) {
                    ctx.drawImage(spriteCache[spriteName], obs.x, obs.y);
                }
            });
            
            // ìˆ˜ì§‘ ì•„ì´í…œ
            collectibles.forEach(item => {
                const bobY = item.y + Math.sin(item.bobOffset) * 5;
                
                let spriteName = item.sprite;
                if (item.type === 'coin') {
                    spriteName = 'coin' + (item.animFrame + 1);
                }
                
                if (spriteCache[spriteName]) {
                    // ë°˜ì§ì„ íš¨ê³¼
                    ctx.globalAlpha = 0.8 + Math.sin(item.bobOffset * 2) * 0.2;
                    ctx.drawImage(spriteCache[spriteName], item.x, bobY);
                    ctx.globalAlpha = 1;
                }
            });
            
            // í”Œë ˆì´ì–´
            drawPlayer();
            
            // íŒŒí‹°í´
            particles.forEach(p => {
                ctx.globalAlpha = p.life / 40;
                ctx.fillStyle = p.color;
                ctx.fillRect(p.x, p.y, p.size, p.size);
                ctx.globalAlpha = 1;
            });
        }
        
        // í”Œë ˆì´ì–´ ê·¸ë¦¬ê¸°
        function drawPlayer() {
            // ê·¸ë¦¼ì
            ctx.fillStyle = 'rgba(0,0,0,0.4)';
            ctx.beginPath();
            ctx.ellipse(player.x + player.width/2, ground.y, player.width/2 - 5, 6, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // ìŠ¤í”„ë¼ì´íŠ¸ ì„ íƒ
            let spriteName;
            if (player.jumping || !player.grounded) {
                spriteName = 'player_jump';
            } else {
                spriteName = 'player_run' + (player.runFrame + 1);
            }
            
            if (spriteCache[spriteName]) {
                ctx.drawImage(spriteCache[spriteName], player.x, player.y);
            }
        }
        
        // ê²Œì„ ì˜¤ë²„
        function gameOver() {
            gameState = 'over';
            document.getElementById('gameOverScreen').classList.remove('hidden');
            document.getElementById('finalScore').textContent = `${score}m`;
            document.getElementById('finalCoins').textContent = `ğŸ’ ${coins}ê°œ ìˆ˜ì§‘`;
            
            // ì‚¬ë§ ì´í™íŠ¸
            createParticle(player.x + player.width/2, player.y + player.height/2, '#f00', 20);
            createParticle(player.x + player.width/2, player.y + player.height/2, PALETTE.cape, 15);
        }
        
        // ê²Œì„ ì‹œì‘
        function startGame() {
            gameState = 'playing';
            score = 0;
            coins = 0;
            speed = 5;
            frameCount = 0;
            obstacles = [];
            collectibles = [];
            particles = [];
            player.y = ground.y - player.height;
            player.vy = 0;
            player.grounded = true;
            player.jumping = false;
            player.runFrame = 0;
            initBackground();
            document.getElementById('startScreen').classList.add('hidden');
            document.getElementById('gameOverScreen').classList.add('hidden');
        }
        
        // ê²Œì„ ë£¨í”„
        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }
        
        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' || e.code === 'ArrowUp') {
                e.preventDefault();
                jump();
            }
        });
        
        document.addEventListener('touchstart', (e) => {
            if (e.target.tagName !== 'BUTTON') {
                e.preventDefault();
                jump();
            }
        }, { passive: false });
        
        document.addEventListener('mousedown', (e) => {
            if (e.target.tagName !== 'BUTTON') {
                jump();
            }
        });
        
        document.getElementById('startBtn').addEventListener('click', startGame);
        document.getElementById('restartBtn').addEventListener('click', startGame);
        
        // ì´ˆê¸°í™”
        initSprites();
        initBackground();
        gameLoop();
    </script>
</body>
</html>
